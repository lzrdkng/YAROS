/*
 * Copyright (C) Olivier Dion <olivier.dion@polymtl.ca>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef SYSCLK_H
#define SYSCLK_H

#include <util/atomic.h>
#include <util/delay.h>

#include "YAROS/def.h"
#include "YAROS/sched.h"
#include "YAROS/global.h"

/*
  The Atmega324PA has a CPU frequency of 8 MHz. The following table
  describe the incidence of the system clock frequency (HZ) on the system.

  The system clock is generated by using the TIMER0_OVF_vect interrupt.

  Here's a description of the different fields.

  *HZ*
  The system clock frequency.

  *Jiffy*
  The smallest unit of time of the system clock.

  *Timer Scale*
  The prescaler needed on the timer to generate the desired HZ.

  *Count*
  Every time the interrupt occured, it's necessary to put in TCNT0 the
  value 0xFF - count.

  *Latency*
  The inverse of the fractional part of *count*. We add one to TCNT0
  every *L* interrupt.

  *Days*
  The number of days before the jiffies counter overflow (32 bits).

  *Work*
  The percentage of work done in the interrupt routine for every jiffy.

  |------+------------+-------------+-------+---------+----------------+----------|
  |   HZ | Jiffy (ms) | Timer Scale | Count | Latency | Days (32 bits) | Work (%) |
  |------+------------+-------------+-------+---------+----------------+----------|
  |   50 |         20 |        1024 |   100 |       4 |            994 |   0.0316 |
  |  100 |         10 |        1024 |   178 |       8 |            497 |   0.0629 |
  |  125 |          8 |         256 |     6 |       0 |            397 |   0.0703 |
  |  200 |          5 |        1024 |   217 |      16 |            248 |   0.1255 |
  |  250 |          4 |         256 |   131 |       0 |            198 |   0.1406 |
  |  500 |          2 |          64 |     6 |       0 |             99 |   0.2813 |
  | 1000 |          1 |          64 |   131 |       0 |             49 |   0.5625 |
  |------+------------+-------------+-------+---------+----------------+----------|
*/

/* For 8Mhz. TODO: Make this good for every frequency */
#if HZ == 50
# define MS 20
# define KCLK_SRC CLK_P1024
# define KCLK_SCALE 1024
# define KCLK_COUNT 100
# define KCLK_LATENCY 4

#elif HZ == 100
# define MS 10
# define KCLK_SRC CLK_P1024
# define KCLK_SCALE 1024
# define KCLK_COUNT 178
# define KCLK_LATENCY 8

#elif HZ == 125
# define MS 8
# define KCLK_SRC CLK_P256
# define KCLK_SCALE 256
# define KCLK_COUNT 6
# define KCLK_LATENCY 0

#elif HZ == 200
# define MS 5
# define KCLK_SRC CLK_P1024
# define KCLK_SCALE 1024
# define KCLK_COUNT 217
# define KCLK_LATENCY 16

#elif HZ == 250
# define MS 4
# define KCLK_SRC CLK_P256
# define KCLK_SCALE 256
# define KCLK_COUNT 131
# define KCLK_LATENCY 0

#elif HZ == 500
# define MS 2
# define KCLK_SRC CLK_P64
# define KCLK_SCALE 64
# define KCLK_COUNT 6
# define KCLK_LATENCY 0

#elif HZ == 1000
# define MS 1
# define KCLK_SRC CLK_P64
# define KCLK_SCALE 64
# define KCLK_COUNT 131
# define KCLK_LATENCY 0

#else
#  error HZ value not supported.
#endif


/*
 * From Linux Kernel: include/linux/jiffies.h
 */
#define time_after(a, b) ((long)((b) - (a)) < 0)
#define time_before(a, b) time_after(b, a)
#define time_after_eq(a, b) ((long)((a) - (b)) >= 0)
#define time_before_eq(a, b) time_after_eq(b, a)

#define mdelay(_ms) _delay_ms(_ms)
#define udelay(_us) _delay_us(_us)

static inline jiffy_t __attribute__((always_inline))
tick()
{
	jiffy_t j;

	cli();
	j = jiffies;
	sei();

	return j;
}

static inline U64 __attribute__((always_inline))
clk(void)
{
	return MS * tick();
}

static inline void __attribute__((always_inline))
wait(jiffy_t delay)
{
	jiffy_t until = tick() + delay;

	while (time_before(tick(), until))
		reschedule();

	return;
}

#endif /* SYSCLK_H */
